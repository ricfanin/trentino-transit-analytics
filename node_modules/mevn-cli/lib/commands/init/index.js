'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _execa = _interopRequireDefault(require("execa"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _inquirer = _interopRequireDefault(require("inquirer"));

var _nodeBanner = _interopRequireDefault(require("node-banner"));

var _validateNpmPackageName = _interopRequireDefault(require("validate-npm-package-name"));

var logger = _interopRequireWildcard(require("../../utils/logger"));

var _helpers = require("../../utils/helpers");

var _validate2 = require("../../utils/validate");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var projectPathRelative;
var projectConfig = {};
/**
 * Creates an initial local commit
 *
 * @returns {Void}
 */

var makeInitialCommit = function makeInitialCommit() {
  // Commands to be executed serially
  var commands = ['init', 'add .', "commit -m \"Init\" -m \"MEVN-CLI\""]; // Execute commands serially

  commands.forEach(function (cmd) {
    return _execa["default"].sync('git', cmd.split(' '), {
      cwd: projectPathRelative
    });
  });
};
/**
 * Logs the further actions to be performed
 *
 * @returns {Void}
 */


var showInstructions = function showInstructions() {
  var isCurrentDir = projectPathRelative === '.';

  var userCommandInstruction = _chalk["default"].green.bold('mevn serve');

  if (!isCurrentDir) {
    userCommandInstruction = "".concat(_chalk["default"].green.bold("cd ".concat(projectPathRelative)), " && ").concat(userCommandInstruction);
  }

  console.log();
  console.log();
  logger.info("You're all set");
  logger.info("Now, just type in ".concat(userCommandInstruction));
  makeInitialCommit();
};
/**
 * Fetch the boilerplate template of choice
 *
 * @param {String} template - The boilerplate template of choice
 * @returns {Promise<void>}
 */


var fetchTemplate = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(template) {
    var dest, templatePath, renameFromPath, renameToPath, configFilePath, configFile, _yield$inquirer$promp, mode, modeIdx, _yield$inquirer$promp2, deployTarget, targetIdx, _yield$inquirer$promp3, requireServer, serverDir, serverPath, source, _dest, _renameFromPath, _renameToPath;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _validate2.validateInstallation)('git help -g');

          case 2:
            // Holds reference to the destination path
            dest = _path["default"].resolve(projectPathRelative); // Holds reference to the path where starter templates reside

            templatePath = _path["default"].join(__dirname, '..', '..', 'templates', 'starter-templates'); // Copy the starter template to user's current working directory

            (0, _helpers.copyDirSync)(_path["default"].join(templatePath, template), dest); // Rename the resultant directory to client

            renameFromPath = _path["default"].join(dest, template);
            renameToPath = _path["default"].join(dest, 'client');

            _fs["default"].renameSync(renameFromPath, renameToPath); // Rename to .gitignore


            _fs["default"].renameSync(_path["default"].join(renameToPath, '.mevngitignore'), _path["default"].join(renameToPath, '.gitignore')); // Prompt the user whether he/she requires pwa support


            if (!(template === 'Nuxt.js')) {
              _context.next = 26;
              break;
            }

            configFilePath = _path["default"].join(projectPathRelative, 'client', 'nuxt.config.js');
            configFile = (0, _helpers.readFileContent)(configFilePath); // Choose the rendering mode

            _context.next = 14;
            return _inquirer["default"].prompt([{
              name: 'mode',
              type: 'list',
              message: 'Rendering mode',
              choices: ['Universal (SSR/SSG)', 'Single Page App']
            }]);

          case 14:
            _yield$inquirer$promp = _context.sent;
            mode = _yield$inquirer$promp.mode;

            // Update the config file (nuxt.config.js)
            if (mode.includes('Universal')) {
              modeIdx = configFile.findIndex(function (line) {
                return line.includes('mode:');
              });
              configFile[modeIdx] = " mode: 'universal',";
            } // Choose the Deployment target


            _context.next = 19;
            return _inquirer["default"].prompt([{
              name: 'deployTarget',
              type: 'list',
              message: 'Deployment target',
              choices: ['Node.js hosting', 'Static (Static/JAMStack hosting)']
            }]);

          case 19:
            _yield$inquirer$promp2 = _context.sent;
            deployTarget = _yield$inquirer$promp2.deployTarget;

            if (deployTarget === 'Node.js hosting') {
              targetIdx = configFile.findIndex(function (line) {
                return line.includes('target:');
              });
              configFile[targetIdx] = "".concat(' '.repeat(2), "target: 'server',");
            } // To be written to project specific config (.mevnrc)


            projectConfig.modules = [];
            projectConfig.renderingMode = mode.includes('Universal') ? 'universal' : 'spa';
            projectConfig.deployTarget = deployTarget.includes('Node.js') ? 'server' : 'static'; // Write back the updated config file (nuxt.config.js)

            _fs["default"].writeFileSync(configFilePath, configFile.join('\n'));

          case 26:
            // Keep track whether dependencies are to be installed
            projectConfig.isConfigured = {
              client: false
            }; // Show up a suitable prompt whether if the user requires a Full stack application (Express.js)

            _context.next = 29;
            return _inquirer["default"].prompt({
              name: 'requireServer',
              type: 'confirm',
              message: 'Do you require server side template (Express.js)'
            });

          case 29:
            _yield$inquirer$promp3 = _context.sent;
            requireServer = _yield$inquirer$promp3.requireServer;

            // Copy server side template files to the destination as required
            if (requireServer) {
              // Configure path
              serverDir = template === 'GraphQL' ? 'GraphQL' : 'Default';
              serverPath = ['templates', 'server', serverDir];
              source = _path["default"].join.apply(_path["default"], [__dirname, '..', '..'].concat(serverPath));
              _dest = _path["default"].resolve(projectPathRelative); // Keep track whether dependencies are to be installed

              projectConfig.isConfigured = {
                client: false,
                server: false
              }; // Copy server template directory to the destination

              (0, _helpers.copyDirSync)(source, _dest); // Rename the resultant directory to server

              _renameFromPath = _path["default"].join(_dest, serverDir);
              _renameToPath = _path["default"].join(_dest, 'server');

              _fs["default"].renameSync(_renameFromPath, _renameToPath);

              _fs["default"].writeFileSync(_path["default"].join(_renameToPath, '.gitignore'), 'node_modules');
            } // Update project specific config file


            _fs["default"].writeFileSync(_path["default"].join(projectPathRelative, '.mevnrc'), JSON.stringify(projectConfig, null, 2)); // Show up initial instructions to the user


            showInstructions();

          case 34:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function fetchTemplate(_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Scaffolds a MEVN stack based webapp
 *
 * @param {String} appName - Name of the project
 * @returns {Promise<void>}
 */


var _default = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(appName) {
    var hasMultipleProjectNameArgs, isCurrentDir, _validate, validForNewPackages, _yield$inquirer$promp4, template;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0, _nodeBanner["default"])('MEVN CLI', 'Light speed setup for MEVN stack based apps.');

          case 2:
            hasMultipleProjectNameArgs = process.argv[4] && !process.argv[4].startsWith('-');
            isCurrentDir = false;

            if (appName === '.') {
              isCurrentDir = true;
              appName = _path["default"].basename(process.cwd());
            } // Validation for multiple directory names


            if (hasMultipleProjectNameArgs) {
              logger.error('\n Error: Kindly provide only one argument as the directory name!!');
              process.exit(1);
            }

            _validate = (0, _validateNpmPackageName["default"])(appName), validForNewPackages = _validate.validForNewPackages;

            if (!validForNewPackages) {
              logger.error(" Error: Could not create a project called \"".concat(_chalk["default"].cyan.bold(appName), "\" because of npm naming restrictions:"));
              process.exit(1);
            }

            if (isCurrentDir) {
              if (_fs["default"].readdirSync('.').length) {
                logger.error("\n It seems the current directory isn't empty.\n");
                process.exit(1);
              }
            }

            if (!isCurrentDir && _fs["default"].existsSync(appName)) {
              logger.error("\n Error: Directory ".concat(_chalk["default"].cyan.bold(appName), " already exists in path!"));
              process.exit(1);
            }

            if (_fs["default"].existsSync('.mevnrc')) {
              logger.error("\n It seems that you're already within a valid MEVN stack based project");
              process.exit(1);
            }

            projectPathRelative = isCurrentDir ? '.' : appName;
            _context2.next = 14;
            return _inquirer["default"].prompt([{
              name: 'template',
              type: 'list',
              message: 'Please choose a starter template',
              choices: ['Default', 'PWA (Progressive Web App)', 'GraphQL', 'Nuxt.js']
            }]);

          case 14:
            _yield$inquirer$promp4 = _context2.sent;
            template = _yield$inquirer$promp4.template;

            // Create a directory in the current path with the given name
            if (!isCurrentDir) {
              _fs["default"].mkdirSync(appName);
            }

            projectConfig['name'] = appName;
            projectConfig['template'] = template.includes('PWA') ? 'PWA' : template;
            fetchTemplate(projectConfig.template);

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}();

exports["default"] = _default;